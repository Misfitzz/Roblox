local Self = script.Parent
local Settings = Self:FindFirstChild'Configurations'
local Mind = Self:FindFirstChild'Mind' 
Self.PrimaryPart:SetNetworkOwner(nil)

--
--
assert(Self:FindFirstChild'Humanoid' ~= nil, 'NPC does not have a humanoid')
assert(Settings ~= nil, 'NPC does not have a Configurations object')
assert(Settings:FindFirstChild'MaximumDetectionDistance' ~= nil and Settings.MaximumDetectionDistance:IsA'NumberValue', 'NPC does not have a MaximumDetectionDistance (NumberValue) setting')
assert(Settings:FindFirstChild'CanGiveUp' ~= nil and Settings.CanGiveUp:IsA'BoolValue', 'NPC does not have a CanGiveUp (BoolValue) setting')
assert(Settings:FindFirstChild'CanRespawn' ~= nil and Settings.CanRespawn:IsA'BoolValue', 'NPC does not have a CanRespawn (BoolValue) setting')
assert(Settings:FindFirstChild'SpawnPoint' ~= nil and Settings.SpawnPoint:IsA'Vector3Value', 'NPC does not have a SpawnPoint (Vector3Value) setting')
assert(Settings:FindFirstChild'AutoDetectSpawnPoint' ~= nil and Settings.AutoDetectSpawnPoint:IsA'BoolValue', 'NPC does not have a AutoDetectSpawnPoint (BoolValue) setting')
assert(Settings:FindFirstChild'FriendlyTeam' ~= nil and Settings.FriendlyTeam:IsA'BrickColorValue', 'NPC does not have a FriendlyTeam (BrickColorValue) setting')
assert(Settings:FindFirstChild'AttackDamage' ~= nil and Settings.AttackDamage:IsA'NumberValue', 'NPC does not have a AttackDamage (NumberValue) setting')
assert(Settings:FindFirstChild'AttackFrequency' ~= nil and Settings.AttackFrequency:IsA'NumberValue', 'NPC does not have a AttackFrequency (NumberValue) setting')
assert(Settings:FindFirstChild'AttackRange' ~= nil and Settings.AttackRange:IsA'NumberValue', 'NPC does not have a AttackRange (NumberValue) setting')
assert(Mind ~= nil, 'NPC does not have a Mind object')
assert(Mind:FindFirstChild'CurrentTargetHumanoid' ~= nil and Mind.CurrentTargetHumanoid:IsA'ObjectValue', 'NPC does not have a CurrentTargetHumanoid (ObjectValue) mind setting')
assert(Self:FindFirstChild'Respawn' and Self.Respawn:IsA'BindableFunction', 'NPC does not have a Respawn BindableFunction')
assert(Self:FindFirstChild'Died' and Self.Died:IsA'BindableEvent', 'NPC does not have a Died BindableEvent')
assert(Self:FindFirstChild'Respawned' and Self.Died:IsA'BindableEvent', 'NPC does not have a Respawned BindableEvent')
assert(Self:FindFirstChild'Attacked' and Self.Died:IsA'BindableEvent', 'NPC does not have a Attacked BindableEvent')
assert(Self:FindFirstChild'NPCScript' and script.Attack:IsA'Animation', 'NPC does not have a NPCScript.Attack Animation')


--
--
local Info = {
	
	Players = game:GetService 'Players',
	PathfindingService = game:GetService 'PathfindingService',
	
	
	RecomputePathFrequency = 1, 
	RespawnWaitTime = 5, 
	JumpCheckFrequency = 1, 
	
}

local Data = {

	LastRecomputePath = 0,
	Recomputing = false, 
	PathCoords = {},
	IsDead = false,
	TimeOfDeath = 0,
	CurrentNode = nil,
	CurrentNodeIndex = 1,
	AutoRecompute = true,
	LastJumpCheck = 0,
	LastAttack = 0,

	BaseNPC = Self:Clone(),
	AttackTrack = nil
}

--
--
local NPC = {} 


function NPC:GetCFrame()

	local humanoidRootPart = Self:FindFirstChild('HumanoidRootPart')

	if humanoidRootPart ~= nil and humanoidRootPart:IsA('BasePart') then
		return humanoidRootPart.CFrame
	else
		return CFrame.new()
	end
end


function NPC:GetMaximumDetectionDistance()

	local setting = Settings.MaximumDetectionDistance.Value

	if setting < 0 then
		return math.huge
	else
		return setting
	end
end


function NPC:SearchForTarget()

	local players = Info.Players:GetPlayers()
	local closestCharacter, closestCharacterDistance

	for i=1, #players do
		local player = players[i]

		if player.Neutral or player.TeamColor ~= Settings.FriendlyTeam.Value then
			local character = player.Character

			if character ~= nil and character:FindFirstChild('Humanoid') ~= nil and character.Humanoid:IsA('Humanoid') then
				local distance = player:DistanceFromCharacter(NPC:GetCFrame().p)

				if distance < NPC:GetMaximumDetectionDistance() then
					if closestCharacter == nil then
						closestCharacter, closestCharacterDistance = character, distance
					else
						if closestCharacterDistance > distance then
							closestCharacter, closestCharacterDistance = character, distance
						end
					end
				end
			end
		end
	end


	if closestCharacter ~= nil then
		Mind.CurrentTargetHumanoid.Value = closestCharacter.Humanoid
	end
end


function NPC:TryRecomputePath()
	if Data.AutoRecompute or tick() - Data.LastRecomputePath > 1/Info.RecomputePathFrequency then
		NPC:RecomputePath()
	end
end


function NPC:GetTargetCFrame()
	local targetHumanoid = Mind.CurrentTargetHumanoid.Value

	if NPC:TargetIsValid() then
		return targetHumanoid.Torso.CFrame
	else
		return CFrame.new()
	end
end


function NPC:IsAlive()
	return Self.Humanoid.Health > 0 and Self.Humanoid.Torso ~= nil
end


function NPC:TargetIsValid()
	local targetHumanoid = Mind.CurrentTargetHumanoid.Value

	if targetHumanoid ~= nil and targetHumanoid:IsA 'Humanoid' and targetHumanoid.Torso ~= nil and targetHumanoid.Torso:IsA 'BasePart' then
		return true
	else
		return false
	end
end


function NPC:HasClearLineOfSight()
	
	local myPos, targetPos = NPC:GetCFrame().p, NPC:GetTargetCFrame().p

	local hit, pos = workspace:FindPartOnRayWithIgnoreList(
		Ray.new(
			myPos,
			targetPos - myPos
		),
		{
			Self,
			Mind.CurrentTargetHumanoid.Value.Parent
		}
	)


	if hit == nil then
		return true
	else
		return false
	end
end


function NPC:RecomputePath()
	if not Data.Recomputing then
		if NPC:IsAlive() and NPC:TargetIsValid() then
			if NPC:HasClearLineOfSight() then
				Data.AutoRecompute = true
				Data.PathCoords = {
					NPC:GetCFrame().p,
					NPC:GetTargetCFrame().p
				}

				Data.LastRecomputePath = tick()
				Data.CurrentNode = nil
				Data.CurrentNodeIndex = 2 
			else
				
				Data.Recomputing = true 
				Data.AutoRecompute = false


				local path = Info.PathfindingService:ComputeSmoothPathAsync(
					NPC:GetCFrame().p,
					NPC:GetTargetCFrame().p,
					500
				)
				Data.PathCoords = path:GetPointCoordinates()


				Data.Recomputing = false
				Data.LastRecomputePath = tick()
				Data.CurrentNode = nil
				Data.CurrentNodeIndex = 1
			end
		end
	end
end


function NPC:Update()
	NPC:ReevaluateTarget()
	NPC:SearchForTarget()
	NPC:TryRecomputePath()
	NPC:TravelPath()
end


function NPC:TravelPath()
	local closest, closestDistance, closestIndex
	local myPosition = NPC:GetCFrame().p
	local skipCurrentNode = Data.CurrentNode ~= nil and (Data.CurrentNode - myPosition).magnitude < 3

	for i=Data.CurrentNodeIndex, #Data.PathCoords do
		local coord = Data.PathCoords[i]
		if not (skipCurrentNode and coord == Data.CurrentNode) then
			local distance = (coord - myPosition).magnitude

			if closest == nil then
				closest, closestDistance, closestIndex = coord, distance, i
			else
				if distance < closestDistance then
					closest, closestDistance, closestIndex = coord, distance, i
				else
					break
				end
			end
		end
	end


	--
	if closest ~= nil then
		Data.CurrentNode = closest
		Data.CurrentNodeIndex = closestIndex

		local humanoid = Self:FindFirstChild 'Humanoid'

		if humanoid ~= nil and humanoid:IsA'Humanoid' then
			humanoid:MoveTo(closest)
		end

		if NPC:IsAlive() and NPC:TargetIsValid() then
			NPC:TryJumpCheck()
			NPC:TryAttack()
		end

		if closestIndex == #Data.PathCoords then

			Data.AutoRecompute = true
		end
	end
end


function NPC:TryJumpCheck()
	if tick() - Data.LastJumpCheck > 1/Info.JumpCheckFrequency then
		NPC:JumpCheck()
	end
end


function NPC:TryAttack()
	if tick() - Data.LastAttack > 1/Settings.AttackFrequency.Value then
		NPC:Attack()
	end
end


function NPC:Attack()
	local myPos, targetPos = NPC:GetCFrame().p, NPC:GetTargetCFrame().p

	if (myPos - targetPos).magnitude <= Settings.AttackRange.Value then
		Mind.CurrentTargetHumanoid.Value:TakeDamage(Settings.AttackDamage.Value)
		Data.LastAttack = tick()
		Data.AttackTrack:Play()
	end
end


function NPC:JumpCheck()

	local myCFrame = NPC:GetCFrame()
	local checkVector = (NPC:GetTargetCFrame().p - myCFrame.p).unit*2

	local hit, pos = workspace:FindPartOnRay(
		Ray.new(
			myCFrame.p + Vector3.new(0, -2.4, 0),
			checkVector
		),
		Self
	)

	if hit ~= nil and not hit:IsDescendantOf(Mind.CurrentTargetHumanoid.Value.Parent) then
		

		local hit2, pos2 = workspace:FindPartOnRay(
			Ray.new(
				myCFrame.p + Vector3.new(0, -2.3, 0),
				checkVector
			),
			Self
		)

		if hit2 == hit then
			if ((pos2 - pos)*Vector3.new(1,0,1)).magnitude < 0.05 then 
				Self.Humanoid.Jump = true
			end
		end
	end

	Data.LastJumpCheck = tick()
end


function NPC:Connect()
	Mind.CurrentTargetHumanoid.Changed:connect(function(humanoid)
		if humanoid ~= nil then
			assert(humanoid:IsA'Humanoid', 'NPC target must be a humanoid')

			NPC:RecomputePath()
		end
	end)

	Self.Respawn.OnInvoke = function(point)
		NPC:Respawn(point)
	end
end


function NPC:Initialize()
	NPC:Connect()

	if Settings.AutoDetectSpawnPoint.Value then
		Settings.SpawnPoint.Value = NPC:GetCFrame().p
	end
end


function NPC:Respawn(point)
	local point = point or Settings.SpawnPoint.Value

	for index, obj in next, Data.BaseNPC:Clone():GetChildren() do
		if obj.Name == 'Configurations' or obj.Name == 'Mind' or obj.Name == 'Respawned' or obj.Name == 'Died' or obj.Name == 'NPCScript' or obj.Name == 'Respawn' then
			obj:Destroy()
		else
			Self[obj.Name]:Destroy()
			obj.Parent = Self
		end
	end

	NPC:InitializeUnique()

	Self.Parent = workspace

	Self.HumanoidRootPart.CFrame = CFrame.new(point)
	Settings.SpawnPoint.Value = point
	Self.Respawned:Fire()
end


function NPC:InitializeUnique()
	Data.AttackTrack = Self.Humanoid:LoadAnimation(script.Attack)
end


function NPC:ReevaluateTarget()
	local currentTarget = Mind.CurrentTargetHumanoid.Value

	if currentTarget ~= nil and currentTarget:IsA'Humanoid' then
		local character = currentTarget.Parent

		if character ~= nil then
			local player = Info.Players:GetPlayerFromCharacter(character)

			if player ~= nil then
				if not player.Neutral and player.TeamColor == Settings.FriendlyTeam.Value then
					Mind.CurrentTargetHumanoid.Value = nil
				end
			end
		end


		if currentTarget == Mind.CurrentTargetHumanoid.Value then
			local torso = currentTarget.Torso

			if torso ~= nil and torso:IsA 'BasePart' then
				if Settings.CanGiveUp.Value and (torso.Position - NPC:GetCFrame().p).magnitude > NPC:GetMaximumDetectionDistance() then
					Mind.CurrentTargetHumanoid.Value = nil
				end
			end
		end
	end
end

--
--
NPC:Initialize()
NPC:InitializeUnique()


while true do
	if not NPC:IsAlive() then
		if Data.IsDead == false then
			Data.IsDead = true
			Data.TimeOfDeath = tick()
			Self.Died:Fire()
		end
		if Data.IsDead == true then
			if tick()-Data.TimeOfDeath > Info.RespawnWaitTime then
				NPC:Respawn()
			end
		end
	end

	if NPC:IsAlive() then
		NPC:Update()
	end

	wait()
end
